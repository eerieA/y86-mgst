#
# Calling conventions:
#     %rdi, %rsi, %rdx, %rcx, %r8, %r9, %r10, %r11 and %rax are caller saved
#     %rbx, %rbp, %r12, %r13, %r14 are callee saved
#     %rsp can not be used except for its normal use as a stack pointer.
#     argument are passed through registers %rdi, %rsi, %rdx in this order.
#     values are returned through %rax

.pos 0x100

main:
	irmovq bottom,  %rsp     # initialize stack
	irmovq array, %rdi       # %rdi = pointer to first element of the array
	xorq   %rax, %rax        # %rsi = size
	mrmovq size(%rax), %rsi
	irmovq $1, %rax          # %rsi = size - 1
	subq   %rax, %rsi
	addq   %rsi, %rsi        # %rsi = 8 * (size - 1)
	addq   %rsi, %rsi
	addq   %rsi, %rsi
	addq   %rdi, %rsi        # %rsi = pointer to last element of the array.
	call   mergesort
	halt

#
# Mergesort
#    %rdi: pointer to the first element of the range to sort.
#    %rsi: pointer to the last element of the range to sort.
#
mergesort:
	rrmovq %rsi, %rax  	    # is first < last ?
	subq   %rdi, %rax
	jle    done             # if not, done.

	rrmovq %rdi, %rdx       # %rdx = mid. Note the use  of ANDQ.
	addq   %rsi, %rdx       # Since we're doing arithmetic  with
	irmovq $2,   %rax       # pointers, we can not rely only  on
	divq   %rax, %rdx       # integer division to ensure  we get
	irmovq $-8,  %rax       # a valid pointer.
	andq   %rax, %rdx       

	pushq  %rdi
	pushq  %rsi             
	pushq  %rdx             
	rrmovq %rdx, %rsi       # mergesort(first, mid)
	call   mergesort
	popq   %rdx
	popq   %rsi
	popq   %rdi
    
	pushq  %rdi             # mergesort(mid+1, last)
	pushq  %rsi             
	pushq  %rdx 
	rrmovq %rdx, %rdi
	irmovq $8, %rax
	addq   %rax, %rdi
	call   mergesort
	popq   %rdx
	popq   %rsi
	popq   %rdi

	call   merge            # merge(first, mid, last)

done:	ret

#
# Merge
#    %rdi: pointer to the first element of the range to merge.
#    %rsi: pointer to the last element of the range to merge.
#    %rdx: pointer to the middle element of the range to merge.
#
# %rdi is i
# %rcx is j
# %rdx is mid
# %rsi is last
# %rbp is dest

merge:
	pushq  %rbp
	pushq  %rbx
	pushq  %rdi
	rrmovq %rdx, %rcx
	irmovq $8,   %rax
	addq   %rax, %rcx
	irmovq temp, %rbp
    
mergeloop1:	
	rrmovq %rdx, %rax          # while (i <= mid && j <= last)
	subq   %rdi, %rax
	jl     mergeloop2
	
	rrmovq %rsi, %rax
	subq   %rcx, %rax
	jl     mergeloop2

	mrmovq 0(%rdi), %rax       # %rax = A[i]
	mrmovq 0(%rcx), %rbx   	   # %ebx = A[j]
	subq   %rax, %rbx          # if A[i] <= A[j]
	jl     mergecopy2

	rmmovq %rax, 0(%rbp)       # copy A[i] to temp
	irmovq $8, %rax
	addq   %rax, %rbp
	addq   %rax, %rdi
	jmp    mergeloop1

mergecopy2:
	mrmovq 0(%rcx), %rbx       # %ebx = A[j] again
	rmmovq %rbx, 0(%rbp)
	irmovq $8, %rax
	addq   %rax, %rbp
	addq   %rax, %rcx
	jmp    mergeloop1

mergeloop2:
	pushq  %rdx
	pushq  %rsi
	rrmovq %rdx, %rsi         # Copy A[i] ... A[mid] to temp.
	rrmovq %rbp, %rdx
	call   copy
	rrmovq %rax, %rbp
	popq   %rsi
	popq   %rdx

    pushq  %rdx               # Copy A[j] ... A[last] to temp.
	pushq  %rsi
	rrmovq %rcx, %rdi
	rrmovq %rbp, %rdx
	call   copy
	rrmovq %rax, %rbp
	popq   %rsi
	popq   %rdx
	
	popq   %rdi
	
	pushq  %rdi
	pushq  %rsi	              # Copy temp back to A[first] ... A[last]
	subq   %rdi, %rsi
	rrmovq %rdi, %rdx
	irmovq temp, %rdi
	addq   %rdi, %rsi
	call   copy
	popq   %rsi
	popq   %rdi

	popq   %rbx
	popq   %rbp
	ret

#
# Copy helper.
#    %rdi [input]: pointer to the first element to copy.
#    %rsi [input]: pointer to the last element to copy.
#    %rdx [input & output]: pointer to where the elements go.
#	
copy:
    irmovq $8, %r8        # Pre-load constant 8 into tmp reg
    
    rrmovq %rsi, %rax     # Prepare for cmp first and last pointers
    subq   %rdi, %rax     # Sets condition codes for the jump
    jl     copyend        # Taken if first > last (default is fwd taken)
    
copycontinue:    
    mrmovq (%rdi), %rax   # Load value from source before updating pointers
    
    addq   %r8, %rdi      # Update pointers while load is happening
    addq   %r8, %rdx      # Can execute while load is pending
    
    # Compare pointers and loop
    rrmovq %rsi, %rbx     # Setup next iteration comparison
    rmmovq %rax, -8(%rdx) # Store loaded value to dest (Reduce stall)
    subq   %rdi, %rbx     # Sets condition codes
    jge    copycontinue   # Loop if more elements to copy
    
copyend:
    rrmovq %rdx, %rax     # Return final destination pointer
    ret


#
# Array to sort
#
.pos 0x1000
array:
		.quad	0x41953
	.quad	0x6d6bc
	.quad	0xb69e1
	.quad	0xd8016
	.quad	0x9b7c0
	.quad	0xf42be
	.quad	0x3752d
	.quad	0x42c87
	.quad	0xcacd1
	.quad	0x53978
	.quad	0x14e88
	.quad	0x79fa2
	.quad	0x834b1

#
# Temporary array.
#
temp:   .quad 0,13


#	
# Array size.
#	
size:   .quad 13
	
#
# Stack (32 sixty-four bit words is more than enough here).
#
.pos 0x3000
top:	            .quad 0x00000000,0x20     # top of stack.
bottom:             .quad 0x00000000          # bottom of stack.

