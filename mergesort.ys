# V2.04
# Calling conventions:
#     %rdi, %rsi, %rdx, %rcx, %r8, %r9, %r10, %r11 and %rax are caller saved
#     %rbx, %rbp, %r12, %r13, %r14 are callee saved
#     %rsp can not be used except for its normal use as a stack pointer.
#     argument are passed through registers %rdi, %rsi, %rdx in this order.
#     values are returned through %rax

.pos 0x100

main:
	irmovq bottom,  %rsp     # initialize stack
	irmovq array, %rdi       # %rdi = pointer to first element of the array
	xorq   %rax, %rax        # %rsi = size
	mrmovq size(%rax), %rsi
	irmovq $1, %rax          # %rsi = size - 1
	subq   %rax, %rsi
	addq   %rsi, %rsi        # %rsi = 8 * (size - 1)
	addq   %rsi, %rsi
	addq   %rsi, %rsi
	addq   %rdi, %rsi        # %rsi = pointer to last element of the array.
	call   mergesort
	halt

#
# Mergesort
#    %rdi: pointer to the first element of the range to sort.
#    %rsi: pointer to the last element of the range to sort.
#
mergesort:                          # Recursive V4.02
    rrmovq %rsi, %rax
    subq   %rdi, %rax               # rax = rsi (last) - rdi (first)
    jg     ms_main                  # If last > first, go to main part
    ret                             # If last <= first, all done

ms_main:
    # Save registers
    pushq  %r12
    rrmovq %rdi, %r12               # r12 = first

    # Calc mid point.
    irmovq $2,   %rax
    addq   %rsi, %r12               # r12 = first + last
    irmovq $-8,  %r11
    pushq  %rbp                     # optimize
    divq   %rax, %r12               # r12 = first + last / 2
    
    rrmovq %rsi, %rbp               # Copy last in rbp
    
    # Calc mid point cont. They are pointers, so andq -8 is a must.
    andq   %r11, %r12               # Chop last 3 bits, now r12 is mid
    
    pushq  %rbx                     # optimize
    rrmovq %rdi, %rbx               # Copy first in rbx

    # Sort left half.               # rdi is already the correct start
    rrmovq %r12, %rsi               # rsi = mid, for mergesort(first, mid)
    call   mergesort

    # Sort right half.
    rrmovq %r12, %rdi
    rrmovq %rbp, %rsi               # rsi = last
    subq   %r11, %rdi               # rdi = mid + 1, for mergesort(mid+1, last)
    call   mergesort

    # Merge the sorted halves
    rrmovq %r12, %rdx               # rdx = mid, for merge()
    rrmovq %rbp, %rsi               # rsi = last, for merge()
    rrmovq %rbx, %rdi               # rdi = first, for merge()
    jmp    merge                    # Tail call optz
    merge_end:

    popq   %rbx
    popq   %rbp
    popq   %r12
    ret

#
# Merge (equivalent to `merge(first, mid, last)`)
#    %rdi: pointer to the first element of the range to merge.
#    %rsi: pointer to the last element of the range to merge.
#    %rdx: pointer to the middle element of the range to merge.
#
# %rdi is i (starts from initial `first`)
# %rcx is j (starts from `last`)
# %rdx is mid
# %rsi is last
# %rbp is dest
merge:                             # V2.02
    pushq  %rbp                    # Save initial dest
    pushq  %rbx                    # Save initial ???, by calling convention
    pushq  %r12                    # Callee-saved - will hold last
    pushq  %r13                    # Callee-saved - will hold mid
    
    irmovq $8,   %r8               # Constant 8 for pointer arithmetic
    
    # Initialize second pointer (j)
    rrmovq %rdx, %rcx              # mid -> rcx
    irmovq temp, %rbp              # Load temp array address early
    addq   %r8, %rcx               # second = mid + 1
    
    # Store bounds in callee-saved registers
    rrmovq %rdx, %r13              # Store mid in r13
    rrmovq %rsi, %r12              # Store last in r12
    
    # Pre-load values for first comparison
    mrmovq 0(%rdi), %r9            # Pre-load A[i]
    mrmovq 0(%rcx), %r10           # Pre-load A[j]
    
    # Initial bounds check (optimize common case)
    rrmovq %r13, %rax    
    subq   %rdi, %rax              # mid(%r13) - first(%rdi)? Mostly >= 0
    jl     prepare_mergeloop2      # Rarely < 0, forward not taken is good
    
    rrmovq %r12, %rax
    subq   %rcx, %rax              # last(%r12) - second(%rcx)? Mostly >= 0
    jl     prepare_mergeloop2      # Rarely < 0, forward not taken is good

    pushq  %rdi                    # Save initial first pointer
    
main_merge_loop:
    # Compare pre-loaded values
    rrmovq %r9, %rax               
    subq   %r10, %rax              # A[i] - A[j]? ~ 50-50%
    jge    store_second            # If A[i] >= A[j], store A[j] (smaller)
    
store_first:                       # Store A[i] (smaller)
    rmmovq %r9, 0(%rbp)            
    addq   %r8, %rdi
    
    # Quick bounds check using dedicated register
    rrmovq %r13, %rax
    addq   %r8, %rbp               # Inc dest
    subq   %rdi, %rax              # mid(%r13) - first(%rdi)? Mostly >= 0
    jge    load_first_continue     # Mostly >= 0, backward taken
    jmp    prepare_mergeloop2      # Rarely < 0, fall through

load_first_continue:
    mrmovq 0(%rdi), %r9            # Pre-load next A[i]
    jmp    main_merge_loop         # Back to main loop

store_second:                      # Store A[j] (smaller)
    rmmovq %r10, 0(%rbp)           
    addq   %r8, %rcx
    
    # Quick bounds check using dedicated register
    rrmovq %r12, %rax
    addq   %r8, %rbp               # Inc dest
    subq   %rcx, %rax              # last(%r12) - second(%rcx)? Mostly >= 0
    jge    load_second_continue    # Mostly >= 0, backward taken
    jmp    prepare_mergeloop2      # Rarely < 0, fall through

load_second_continue:
    mrmovq 0(%rcx), %r10           # Pre-load next A[j]
    jmp    main_merge_loop

prepare_mergeloop2:
    # Handle leftovers from first half
    rrmovq %r13, %rsi              # Setup args for copy: mid -> last pointer
    rrmovq %rbp, %rdx              # temp -> dest pointer
    call   copy
    rrmovq %rax, %rbp              # Save new temp pointer
    
    # Handle leftovers from second half
    rrmovq %rcx, %rdi              # second -> first pointer
    rrmovq %r12, %rsi              # Use last from r12
    call   copy
    rrmovq %rax, %rbp              # Save final temp pointer
    
    # Copy everything back to original array
    popq   %rdi                    # Restore initial first pointer
    
    # Setup final copy
    pushq  %rdi                    # Save initial `first` again
    rrmovq %r12, %rsi              # Use last from r12. So no need to push %rsi, and %rsi not scrathed by copy()
    subq   %rdi, %rsi              # %rsi = `last` - initial `first`
    rrmovq %rdi, %rdx              # Original array as destination
    irmovq temp, %rdi              # `temp` points to the first ele for copy()
    addq   %rdi, %rsi              # `temp` + `last` - initial `first` has the last ele for copy()
    
    call   copy
    
    # Cleanup and return
    popq   %rdi                    # Restore initial `first`
    popq   %r13                    # Restore callee-saved
    popq   %r12                    # Restore callee-saved
    popq   %rbx                    # Restore callee-saved
    popq   %rbp                    # Restore callee-saved
    #ret
    jmp merge_end

#
# Copy helper. Optimized to scratch and use caller-saved reg r11
#    %rdi [input]: pointer to the first element to copy.
#    %rsi [input]: pointer to the last element to copy.
#    %rdx [input & output]: pointer to where the elements go.
# 
copy:
    irmovq $8, %r8                 # Pre-load constant 8
    
    rrmovq %rsi, %rax              # Prepare for comparison
    subq   %rdi, %rax              # Sets condition codes
    jl     copyend                 # Taken if first > last
    
copycontinue:
    mrmovq (%rdi), %rax            # Load value from source
    
    addq   %r8, %rdi               # Update pointers while load is happening
    addq   %r8, %rdx
    
    rrmovq %rsi, %r11              # Use caller-saved r11 for comparison
    rmmovq %rax, -8(%rdx)          # Store loaded value
    subq   %rdi, %r11              # Sets condition codes
    jge    copycontinue            # Loop if more elements
    
copyend:
    rrmovq %rdx, %rax              # Return final destination pointer
    ret


#
# Array to sort
#
.pos 0x1000
array:
	.quad	0x41953		  # 268627
	.quad	0x6d6bc		  # 448188
	.quad	0xb69e1		  # 748001
	.quad	0xd8016		  # 884758
	.quad	0x9b7c0		  # 636864
	.quad	0xf42be		  # 1000126
	.quad	0x3752d		  # 226605
	.quad	0x42c87		  # 273543
	.quad	0xcacd1		  # 830673
	.quad	0x53978		  # 342392
	.quad	0x14e88		  # 85640
	.quad	0x79fa2		  # 499618
	.quad	0x834b1		  # 537777

#
# Temporary array.
#
temp:   .quad 0,13


#	
# Array size.
#	
size:   .quad 13
	
#
# Stack (32 sixty-four bit words is more than enough here).
#
.pos 0x3000
top:	            .quad 0x00000000,0x20     # top of stack.
bottom:             .quad 0x00000000          # bottom of stack.

